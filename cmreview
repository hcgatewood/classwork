'''
Crowdsourced Movie Review
Algorithm testing
cmreview.py
by hcgatewood

Notes:
get additional data
convert movies to class and print list
create profile class and siteuser class
move data from csv file to sql
Add GUI ratings input
add front-end projection metric converting to percentage on [0%,100%]
get movie data from imdb
'''

import csv
import math

'''
Classes
'''
class Globals:
	def __init__(self):
		self.ratingCodes = {
				0:'Hate it',1:'Like it',2:'Love it',-1:"Haven't seen it"}
		self.R_HATE = 0
		self.R_LIKE = 1
		self.R_LOVE = 2
		self.R_UNSEEN = -1
		self.seenItString = "You've already rated this title"
		self.F_HATE = -5
		self.F_LIKE = 1
		self.F_LOVE = 3
		self.TRUST_PERCENT = .15
		self.TRUST_MIN = 5
		self.ratingComparisons = {
				(0,0): 5,
				(0,1): -3,
				(0,2): -5,
				(0,None): 0,
				(1,0): -3,
				(1,1): 0,
				(1,2): 1,
				(1,None): 0,
				(2,0): -5,
				(2,1): 1,
				(2,2): 5,
				(2,None): 0,
				(None,0): 0,
				(None,1): 0,
				(None,2): 0,
				(None,None): 0}


class Wight:
	def __init__(self,name,ratingDict):
		self.name = name
		self.ratings = ratingDict # Dict in form {[movieName]:[intRating]}
		self.comparisons = dict() # Dict in form {[Wight inst]:compareMetric}
		self.trustworthy = set() # Set of Wight classes
		self.projections = dict() # Dict in form {[movieName]:[projMetric]}
		self.projectionsSeen = dict()
		self.projectionsUnseen = dict()
		self.toWatchList = list() #Ordered list of projectionsUnseen

	def get_rating(self,movie):
		return self.ratings[movie]

	def get_comparison(self,altName):
		return self.comparisons[altName]

	def get_projection(self,movie,projKey='fond'):
		'''Return projection for given movie the current Wight instance.

		Tags:
		'all': return tuple (hate,like,love,fondnessMetric)
		'hate': return hate
		'like': return like
		'love': return love
		'fond': return fondnessMetric
		'''
		if projKey == 'all': return self.projections[movie]
		if projKey == 'hate': return self.projections[movie][0]
		if projKey == 'like': return self.projections[movie][1]
		if projKey == 'love': return self.projections[movie][2]
		if projKey == 'fond': return self.projections[movie][3]

	def get_unseen(self):
		return [
				movie for movie in self.ratings
				if self.get_rating(movie)==glo.R_UNSEEN]

	def addTo_comparisons(self,altWight,agreeMetric):
		self.comparisons[altWight] = agreeMetric
		return None

	def addTo_trustworthy(self,altWight):
		self.trustworthy.add(altWight)
		return None

	def addTo_projections(self,movie,hate,like,love,fondnessMetric):
		self.projections[movie] = (hate,like,love,fondnessMetric)
		if movie in self.get_unseen():
			self.projectionsUnseen[movie] = (hate,like,love,fondnessMetric)
		else:
			self.projectionsSeen[movie] = (hate,like,love,fondnessMetric)
		return None

	def print_ratings(self):
		sortList = [
				(movie,self.get_rating(movie))
				for movie in self.ratings]
		printList = sorted(sortList,key=lambda u:u[1],reverse=True)
		print (self.name,': ',printList,sep='')
		return None

	def print_comparisons(self):
		sortList = [
				(alt.name,self.get_comparison(alt))
				for alt in self.comparisons]
		printList = sorted(sortList,key=lambda u:u[1],reverse=True)
		print (self.name,': ',printList,sep='')
		return None

	def print_trustworthy(self):
		sortList = [
				(alt.name,self.get_comparison(alt))
				for alt in self.trustworthy]
		printList = sorted(sortList,key=lambda u:u[1],reverse=True)
		print (self.name,': ',printList,sep='')
		return None

	def print_projections(self,tag='all'):
		'''Print projections for the Wight instance.

		Tags:
		'all': print projections for all movies
		'seen': print projections for seen movies only
		'unseen': print projections for unseen movies only
		'''
		if tag == 'all': proj = self.projections
		elif tag == 'seen': proj = self.projectionsSeen
		elif tag == 'unseen': proj = self.projectionsUnseen
		sortList = [
				(movie,self.get_projection(movie))
				for movie in self.ratings]
		printList = sorted(sortList,key=lambda u:u[1],reverse=True)
		print (self.name,': ',printList,sep='')
		return None

	def print_toWatchList(self):
		print(self.name,': ',self.toWatchList,sep='')

	def print_all(self):
		print(self.name.upper(),':',sep='')
		print('Ratings:')
		self.print_ratings()
		print('')
		print('Comparisons:')
		self.print_comparisons()
		print('')
		print('Trustworthy:')
		self.print_trustworthy()
		print('')
		print('Projections')
		self.print_projections()
		print('')
		print('To Watch List:')
		self.print_toWatchList()
		print('\n'*2)
		return None

	def return_projection(self,movie):
		return self.projections[movie]

	def build_comparisons(self,wightSet):
		for alt in wightSet:
			sharedCount = 0
			compareMetric = 0
			for movie in self.ratings:
				own = self.get_rating(movie)
				other = alt.get_rating(movie)
				if own != -1 and other != -1:
					sharedCount += 1
					compareMetric += glo.ratingComparisons[(own,other)]
			if sharedCount != 0:
				agreeMetric = compareMetric/sharedCount
			else:
				agreeMetric = 0
			self.addTo_comparisons(alt,agreeMetric)
		return None

	def build_trustworthy(self):
		comparisonList = [
				(wight,self.get_comparison(wight))
				for wight in self.comparisons]
		orderedAlt = sorted(comparisonList,key=lambda u:u[1],reverse=True)
		altCount = len(orderedAlt)
		trustCount = math.ceil(altCount*glo.TRUST_PERCENT)
		for u in range(max(trustCount,glo.TRUST_MIN)):
			self.addTo_trustworthy(orderedAlt[u][0])
		return None

	def build_projections(self):
		for movie in self.ratings:
			ratingCount = 0
			hate = 0
			like = 0
			love = 0
			fondnessMetric = 0
			for alt in self.trustworthy:
				other = alt.get_rating(movie)
				if other != -1: ratingCount += 1
				if other == glo.R_HATE: hate += 1
				if other == glo.R_LIKE: like += 1
				if other == glo.R_LOVE: love += 1
			fHate = hate*glo.F_HATE
			fLike = like*glo.F_LIKE
			fLove = love*glo.F_LOVE
			if ratingCount != 0:
				fondnessMetric = (fHate+fLike+fLove)/ratingCount
			else: fondnessMetric = 0
			self.addTo_projections(movie,hate,like,love,fondnessMetric)
		return None

	def build_toWatchList(self):
		unseen = self.get_unseen()
		unsorted = [(movie,self.get_projection(movie)) for movie in unseen]
		self.toWatchList = sorted(unsorted,key=lambda u:u[1],reverse=True)
		return None	


class WightSet:
	'''Set of Wight instances with operable functions.'''
	def __init__(self,fileName):
		wightInfo = self.import_csvWightInfo(
				'C:\\Users\\huntergatewood\\Desktop\\cm_ratings.csv')
		self.members = self.build_wightSet(wightInfo)
		self.nameToWightInstance = dict()
		self.orderedWightList = list()
		self.update_all(self.members)


	def import_csvWightInfo(self,fileName):
		'''Import wight info from csv file; return list of tuples 
		in the form: (name,ratingDict)
		'''
		with open(fileName) as csvfile:
			wightInfo = list()
			rawData = list(csv.reader(csvfile))
		movies = rawData[0][1:]
		ratingData = rawData[2:]
		for ratingList in ratingData:
			ratingDict = dict()
			name = ratingList[0]
			for u in range(1,len(movies)+1):
				movie = movies[u-1]
				rating = ratingList[u]
				try:
					rating = int(rating)
				except:
					rating = None
				ratingDict[movie] = rating
			wightInfo.append((name,ratingDict))
		return wightInfo

	def build_wightSet(self,infoList):
		'''Return a set of Wight instances from infoList'''
		wightSet = set()
		for wight in infoList:
			name = wight[0]
			ratingDict = wight[1]
			wightSet.add(Wight(name,ratingDict))
		return wightSet

	def update_all(self,updateSet):
		for wight in updateSet:
			wight.build_comparisons(self.members)
			wight.build_trustworthy()
			wight.build_projections()
			wight.build_toWatchList()
			self.build_nameToWightInstance()
			self.build_orderedWightList()
		return None

	def build_nameToWightInstance(self):
		nameToWight = dict()
		for member in self.members:
			nameToWight[member.name] = member
		self.nameToWightInstance = nameToWight
		return None

	def build_orderedWightList(self):
		printList = list()
		for wight in self.members:
			printList.append(wight)
		self.orderedWightList = sorted(printList,key=lambda u:u.name)	
		return None	

	def instance_from_name(self,wightName):
		'''Return name attribute from wight instance, if possible.'''
		try:
			wight = self.nameToWightInstance[wightName]
		except:
			return None
		return wight

	def return_projection(self,name,movie):
		return self.instance_from_name(name).return_projection(movie)

	def print_ratings(self):
		for wight in self.orderedWightList:
			wight.print_ratings()
			print('')
		return None

	def print_comparisons(self):
		for wight in self.orderedWightList:
			wight.print_comparisons()
			print('')
		return None

	def print_trustworthy(self):
		for wight in self.orderedWightList:
			wight.print_trustworthy()
			print('')
		return None

	def print_projections(self,tag='all'):
		'''Print projections for the WightSet instance.

		Tags:
		'all': print projections for all movies
		'seen': print only projections for seen movies
		'unseen': print only projections for unseen movies
		'''
		for wight in self.orderedWightList:
			wight.print_projections(tag)
			print('')
		return None

	def print_toWatchList(self):
		for wight in self.orderedWightList:
			wight.print_toWatchList()
			print('')
		return None

	def print_all(self):
		print('RATINGS:')
		self.print_ratings()
		print('\n'*3,'COMPARISONS:',sep='')
		self.print_comparisons()
		print('\n'*3,'TRUSTWORTHY:',sep='')
		self.print_trustworthy()
		print('\n'*3,'PROJECTIONS',sep='')
		self.print_projections()
		print('\n'*3,'TO WATCH LIST',sep='')
		self.print_toWatchList()
		print('\n'*3)
		return None


class Movie:
	def __init__(movieName,releaseDate,genresList,runTime,metascore):
		self.name = movieName
		self.releaseDate = releaseDate
		self.genres = genresList
		self.runTime = runTime
		self.metascore = metascore
		self.avgWightScore = 0
		self.percentile = None
'''
Main functions
'''
glo = Globals()

def run():
	s_clear()
	glo = Globals()
	wightSet = WightSet(
			'C:\\Users\\huntergatewood\\Desktop\\cm_ratings.csv')
	wightSet.print_all()
	wightSet.instance_from_name('Hunter').print_all()
	wightSet.instance_from_name('Matt').print_all()
	return None


'''
Helper functions
'''
def s_clear():
	print('\n'*5)
	return None
