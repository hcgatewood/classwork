package expresso;

import java.util.Map;

import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.TokenStream;
import org.antlr.v4.runtime.tree.ParseTree;

import expresso.parser.ExpressionLexer;
import expresso.parser.ExpressionParser;

/**
 * Immutable Expression interface for concrete representations of algebraic expressions.
 *
 * @author Hunter Gatewood
 * @author Sidd Seethepalli
 * @author Giri Anand
 */
public interface Expression {

    /*
     * Datatype definition
     * Expression = Operator(left:Expression, right:Expression)
     *          + Number(value:Integer or Double)
     *          + Variable(name:String) + Empty
     * Operator = Multiply(left:Expression, right:Expression)
     *          + Add(left:Expression, right:Expression)
     */


    /**
     * Traverse a ParseTree generated by ANTLR and return the corresponding Expression as an abstract syntax tree (AST).
     * @param tree ParseTree from which expression is to be generated
     * @return Expression corresponding to tree represented as an AST
     */
    static Expression toAST(ParseTree tree){
        Expression expression = new Empty();
        if(tree.getClass().equals(ExpressionParser.RootContext.class)){ //if at root, get left child (exp)
            expression = toAST(tree.getChild(0));
        } else if(tree.getChildCount() > 1){ //exp is not a literal
            if(tree.getChild(1).getClass().equals(ExpressionParser.PlusContext.class)){ //exp is a sum of two exps
                expression = new Add(toAST(tree.getChild(0)), toAST(tree.getChild(2)));
            } else if(tree.getChild(1).getClass().equals(ExpressionParser.TimesContext.class)){ //exp is a product of two exps
                expression = new Multiply(toAST(tree.getChild(0)), toAST(tree.getChild(2)));
            } else if(tree.getChild(1).getClass().equals(ExpressionParser.ExpContext.class)){ //exp is an exp in parentheses
                expression = toAST(tree.getChild(1));
            }
        } else if(tree.getChildCount() == 1){ //exp is a literal
            if(tree.getChild(0).getClass().equals(ExpressionParser.VarContext.class)){ //exp is a variable
                expression = new Variable(tree.getChild(0).getText());
            } else if(tree.getChild(0).getClass().equals(ExpressionParser.NumberContext.class)){ //exp is a number
                expression = new Number(Double.parseDouble(tree.getChild(0).getText()));
            }
        }
        return expression;
    }

    /**
     * Parse an expression.
     * @param input expression to parse
     * @return expression AST for the input
     * @throws IllegalArgumentException if the expression is invalid
     */
    public static Expression parse(String input) throws IllegalArgumentException {
        try {
            ANTLRInputStream stream = new ANTLRInputStream(input);
            ExpressionLexer lexer = new ExpressionLexer(stream);
            lexer.reportErrorsAsExceptions();
            TokenStream tokens = new CommonTokenStream(lexer);
            ExpressionParser parser = new ExpressionParser(tokens);
            parser.reportErrorsAsExceptions();
            ParseTree tree = parser.root();
            return toAST(tree);
        } catch (RuntimeException re) {
            throw new IllegalArgumentException();
        }
    }

    /**
     * Take the derivative of an expression with respect to a variable
     * @param variable expression containing the variable with respect
     *        to which the derivative will be taken
     * @return expression that is the derivative of input
     */
    public Expression differentiate(Variable variable);

    /**
     * Simplify an expression.
     * @return an Expression which is mathematically equivalent to the current expression; where for all variables var_i in the overall expression,
     *         and all corresponding real exponents e_i, the term (var_1^e_1 * var_2^e_2 * ... * var_n^e_n) appears at most once;
     *         each term may be multiplied by a  non-zero, non-identity (except for the constant term) constant factor;
     *         and read left-to-right, the largest exponent in each term is non-increasing
     */
    public Expression simplify();

    /**
     * Compile a list of terms in an expression.
     * @return An immutable Map which maps terms to their coefficients in the expression. The terms are represented by a Map which maps variables
     *          to their exponents in the term
     */
    Map<Map<Variable, Integer>, Double> compileTerms();

    /**
     * Gets a string representation of the expression
     * which preserves its AST representation.
     * @return a tree-preserving string representation of the current Expression
     */
    public String toStringAST();

    /**
     * Determines whether the expression is the empty expression.
     * @return true if the expression is the empty expression, false otherwise
     */
    public boolean isEmpty();

    /**
     * Gets a string representation of the expression
     * which is human-readable and console-printable.
     * @return a console-printable string representation of the current Expression
     */
    @Override
    public String toString();

    /**
     * Gets the hash code for the expression.
     * @return hashCode for Expression object
     */
    @Override
    public int hashCode();

    /**
     * Tests expression equality.
     *
     * Structural equality is defined as follows:
     * The expressions contain the same variables, values, and operators;
     * those variables, values, and operators are in the same order and
     * are grouped the same way pairwise according to order of operations.
     * When order of operations does not apply, pairwise groupings are read
     * from left to right. For example, the expression a + b + c
     * is structurally represented as  (a + b) + c and not as
     * a + (b + c).
     *
     * @param obj
     * @return true if Expression objects are structurally equal,
     */
    @Override
    public boolean equals(Object obj);

    /**
     * Returns true if the expression needs to be encased in parentheses
     * when it is a sub-expression of a multiply operation.
     * @return true if the expression needs parens as a sub-expression of Multiply
     */
    public boolean needsParens();
}